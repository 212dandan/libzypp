<html>
<head>
	<title>ini_file</title>
	<style>
		body {
			margin: 0px;
		}
		.code {
			font-family: monospace;
			background-color: #f8f8f8;
			border: 1px solid #c0c0c0;
			margin: 5px;
		}
		.fig {
			color: grey;
			font-style: italic;
			font-size: 80%;
		}
	</style>
</head>
<body>
	<div style="margin: 15px;">
	<h1>ini_file helpers</h1>

	<p>
		Go to the <a href="http://boost-extras.sourceforge.net/documentation.html">Boost-Extra Home Page</a>.
	</p>

  <h2>Summary</h2>

	<blockquote>
		<ul>
			<li><a href="#introduction">Introduction</a></li>
			<li><a href="#usage">Usage</a></li>
			<li><a href="#thread">Thread Consideration</a></li>
			<li><a href="#advantages">Advantages of these Classes</a></li>
			<li><a href="#synopsis">Synopsis</a></li>
			<li><a href="#members">Members</a></li>
			<ul>
				<li><a href="#ini_exceptions">ini_exceptions</a></li>
				<li><a href="#param">param</a></li>
				<li><a href="#param_map">param_map</a></li>
				<li><a href="#section">section</a></li>
				<li><a href="#section_map">section_map</a></li>
				<li><a href="#helpers">Helper Functions</a></li>
			</ul>
			<li><a href="ini_file_header.html">ini_file.hpp</a></li>
		</ul>
	</blockquote>


	<h2><a name="introduction">Introduction</a></h2>
	<p>
		The <b>ini_file</b> classes are used to read and write INI files.
		The format of an INI file is defined as follow:
	</p>
	<ul>
		<li>Files are composed of comments, sections and parameters</li>
		<li>Comments start with a semi-colon (;) at the very beginning
				of a line</li>
		<li>Sections names are defined between square brackets ([ and ]) and
				start at the very beginning of a line</li>
		<li>Parameters are defined as a name, followed by an equal sign
				followed by a value. There can be spaces before and after the
				equal sign. Spaces at the end of a value are also trimmed.</li>
		<li>Empty lines are legal and skipped silently.</li>
	</ul>
	<p>
		There is an example:
	</p>
<pre class="code">

  <font color="blue">; INI file sample</font>
  <font color="purple">[section1]</font>
  <font color="green">var1=value1</font>
  <font color="green">var2 = value2</font>

  <font color="purple">[section2]</font>
  <font color="green">var3= value3</font>
  <font color="green">var4 =value4</font>

</pre>
<center><span class="fig">Example 1. file format definition</span></center>


	<h2><a name="usage">Usage</a></h2>
	<p>
		An INI file is represented by a set of sections and one set of
		parameters per section. Sets are defined as maps. Sections and
		parameters have a name, a comment and parameters also have a
		value. All of these objects are represented below:
	</p>
	<p>
		<table align="center"><tbody><tr><td align="center">
		<div style="border: 1px black solid; padding: 10px; text-align: center;">
			<img src="ini_file.png" width="509" height="265"/>
		</div>
		<span class="fig">Fig 1. Representation of the ini_file classes.</span>
		</td></tr></tbody></table>
	</p>

	<p>
		So creating and saving an INI file comes down to:
	</p>
	
	<ul>
		<li>instantiating a <b>section_map</b> object;</li>
		<li>adding parameters in sections;</li>
		<li>saving the INI file with the &lt;&lt; operator.</li>
	</ul>

<pre class="code">

  <font color="blue">// create an ini file and save it to std::cout</font>
  int main(int argc, char *argv[])
  {
    ini_file::section_map ini;

    ini["section1"]["var1"] = "value of var1";
    ini["section1"]["var2"] = "value of var2";
    ini["section2"]["var3"] = "value of var3";
    ini["section2"]["var4"] = "value of var4";

    std::cout &lt;&lt; ini;
  };

</pre>
<center><span class="fig">Example 2. create an INI file</span></center>

	<p>
		In a similar fashion, it is possible to read and use an INI file by:
	</p>

	<ul>
		<li>instantiating a <b>section_map</b> object;</li>
		<li>reading an INI file with the &gt;&gt; operator;</li>
		<li>getting the parameters value.</li>
	</ul>

<pre class="code">

  <font color="blue">// read an ini file from a stream and print out the content</font>
  int main(int argc, char *argv[])
  {
    ini_file::section_map ini;

    {
      // first we create a file that we can then read
      std::fstream output;
      output.open("test_file.ini", std::fstream::out);
      output &lt;&lt; "; This is an auto-generated test file." &lt;&lt; std::endl;
      output &lt;&lt; "[section1]" &lt;&lt; std::endl;
      output &lt;&lt; "var1=This is variable ONE" &lt;&lt; std::endl;
      output &lt;&lt; "var2=This is variable TWO" &lt;&lt; std::endl;
      output &lt;&lt; "[section2]" &lt;&lt; std::endl;
      output &lt;&lt; "var3 = \" This is \\\"variable\\\" THREE \" " &lt;&lt; std::endl;
      output &lt;&lt; "; Comment on variable 4" &lt;&lt; std::endl;
      output &lt;&lt; "var4=This is variable FOUR" &lt;&lt; std::endl;
    } // file closes

    // now try to read it and print out the content
    std::fstream input;
    input.open("test_file.ini", std::fstream::in);

    input &gt;&gt; ini;

    std::cout &lt;&lt; "section1 -&gt; " &lt;&lt; ini["section1"];
    std::cout &lt;&lt; "section1.var1 -&gt; " &lt;&lt; ini["section1"]["var1"];
    std::cout &lt;&lt; "section1.var2 -&gt; " &lt;&lt; ini["section1"]["var2"];
    std::cout &lt;&lt; "section2 -&gt; " &lt;&lt; ini["section2"];
    std::cout &lt;&lt; "section2.var3 -&gt; " &lt;&lt; ini["section2"]["var3"];
    std::cout &lt;&lt; "section2.var4 -&gt; " &lt;&lt; ini["section2"]["var4"];
  };

</pre>
<center><span class="fig">Example 3. reading an INI file and print the data</span></center>




	<h2><a name="thread">Thread</a></h2>
	<p>
		These classes are not thread safe. However, if read once from disk and
		then used only as constant objects, it will work even if accessed between
		multiple threads (assuming that the boost::shared_ptr&lt;&gt; is thread
		safe.)
	</p>



	<h2><a name="advantages">Advantages of these Classes</a></h2>

	<p>
		Ease of use to read and write INI files including comments
		(comments aren't getting lost.)
	</p>




	<h2><a name="synopsis">Synopsis</a></h2>

<blockquote>
<pre class="code">

  namespace ini_file
  {
    namespace ini_exceptions
    {
      class ini_file_exception    : std::exception {};
      class section_name_missing  : ini_file_exception {};
      class invalid_section_name  : ini_file_exception {};
      class param_name_missing    : ini_file_exception {};
      class invalid_param_name    : ini_file_exception {};
      class invalid_parameter     : ini_file_exception {};
      class param_without_section : ini_file_exception {};
      class invalid_quotation     : ini_file_exception {};
    }   // namespace ini_exceptions

    struct param : ...
    {
                             param(const std::string&amp; _name);
      const std::string&amp;     get_name() const;
      void                   set_comment(const std::string&amp; _comment);
      const std::string&amp;     get_comment() const;
      void                   set_value(const std::string&amp; _value);
      const std::string&amp;     get_value() const;
      param&amp;                 operator = (const std::string&amp; _value);
                             operator const std::string&amp; () const;
    };

    struct param_map : ...
    {
      void                   insert(boost::shared_ptr&lt;param&gt; _p);
      param&amp;                 operator [] (const std::string&amp; _name);
      const param&amp;           operator [] (const std::string&amp; _name) const;
    };

    struct section : ...
    {
                             section(const std::string&amp; _name);
      const std::string&amp;     get_name() const;
      void                   set_comment(const std::string&amp; _comment);
      const std::string&amp;     get_comment() const;
      void                   insert(boost::shared_ptr&lt;param&gt; _p);
      param&amp;                 operator [] (const std::string&amp; _name);
      const param&amp;           operator [] (const std::string&amp; _name) const;
    };

    struct section_map : ...
    {
      void                   insert(boost::shared_ptr&lt;section&gt; _p);
      section&amp;               operator [] (const std::string&amp; _name);
      const section&amp;         operator [] (const std::string&amp; _name) const;
    };

    extern std::istream&amp; operator &gt;&gt; (std::istream&amp; in, section_map&amp; _section_map);

    extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const param&amp; _param);
    extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const section&amp; _section);

    extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const param_map&amp; _param_map);
    extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const section_map&amp; _section_map);
  }

</pre>
</blockquote>



	<h2><a name="members">Members</a></h2>

		<h3>&nbsp; <a name="ini_exceptions">ini_exceptions</a></h3>

		<ul>
			<li><b>ini_file_exception</b></li>
			<p>
				All the ini_file exceptions derive from <b>ini_file_exception</b>.
				In order to catch all the exceptions at once, catch this exception.
			</p>
      <li><b>section_name_missing</b></li>
			<p>
				This exception is thrown when a section with no name is being saved.
			</p>
      <li><b>invalid_section_name</b></li>
			<p>
				This exception is thrown when the parser reading a file finds a line
				which starts with '[' and either does not finish with ']' or defines
				an empty name (only spaces or just '[]').
			</p>
      <li><b>param_name_missing</b></li>
			<p>
				This exception is thrown when a parameter with no name is being saved.
			</p>
      <li><b>invalid_param_name</b></li>
			<p>
				This exception is thrown when the parser finds a parameter name which
				does not start with one of these characters: [a-zA-Z_].
			</p>
      <li><b>invalid_parameter</b></li>
			<p>
				This exception is thrown when parsing a file and the variable name is
				not followed by an equal sign and a value.
			</p>
      <li><b>param_without_section</b></li>
			<p>
				This exception is thrown when parsing a file and a variable is found
				before a section.
			</p>
      <li><b>invalid_quotation</b></li>
			<p>
				This exception is thrown when parsing a quoted parameter which has no
				closing quotation.
			</p>
		</ul>






		<h3>&nbsp; <a name="param">param</a></h3>

		<blockquote>
			<pre>param(const std::string&amp; _name);</pre>
			<blockquote>
				<p>
					<b>Preconditions:</b> the parameter name is not empty; though this is
					currently not enforced since we need a default parameter with an empty
					name (see the [] operators.)
				</p>
				<p>
					<b>Effects:</b> create a parameter named <code>_name</code>.
				</p>
				<p>
					<b>Postconditions:</b> the parameter name cannot be changed.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>const std::string&amp; get_name() const;</pre>
			<blockquote>
				<p>
					<b>Postconditions:</b> the returned string cannot be modified.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>void set_comment(const std::string&amp; comment);</pre>
			<blockquote>
				<p>
					<b>Effects:</b> assigns a comment to that object. Comments
					are written right before parameters. Comments read right
					before a paramater are assigned to that parameter.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>const std::string&amp; get_comment() const;</pre>
			<blockquote>
				<p>
					<b>Postconditions:</b> the returned string cannot be modified; use
					<b>set_comment()</b> to modify a comment.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>void set_value(const std::string&amp; _value);
param&amp; operator = (const std::string&amp; _value)</pre>
			<blockquote>
				<p>
					<b>Effects:</b> assigns a new value to the parameter. Anything is
					valid except a new line character and a null character. If the
					parameter value starts or ends with spaces or quotes, the value
					will be saved quoted.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>const std::string&amp; get_value() const;
operator const std::string&amp; () const;</pre>
			<blockquote>
				<p>
					<b>Effects:</b> retrieve the current value of the parameter.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>




		<h3>&nbsp; <a name="param_map">param_map</a></h3>

		<blockquote>
			<pre>void insert(boost::shared_ptr&lt;param&gt; _p);</pre>
			<blockquote>
				<p>
					<b>Precondition:</b> if the pointer is null, nothing happens and the
					function returns right away.
				</p>
				<p>
					<b>Effects:</b> add the specified parameter in the map of parameters.
					The use of a map makes it faster to retrieve parameters. However, this
					means you lose the possible ordering from input files.
				</p>
				<p>
					<b>Throws:</b> memory allocation exceptions
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>param&amp; operator [] (const std::string&amp; _name);
const param&amp; operator [] (const std::string&amp; _name) const;</pre>
			<blockquote>
				<p>
					<b>Precondition:</b> if a parameter with the specified <code>_name</code>
					does not exist:
					<ul>
						<li><i>Non-constant parameter map</i></li>
						<p>
							When the non-constant operator is used, a new parameter
							is created if none already exist with that <code>_name</code>.
						</p>
						<p>
						<li><i>Constant parameter map</i></li>
						<p>
							When the constant operator is used, it returns an empty
							parameter which must not be modified.
							That empty parameter is not part of the map.
						</p>
					</ul>
				</p>
				<p>
					<b>Effects:</b> return the empty parameter, an existing parameter or
					a new parameter with the specified <code>_name</code>.
				</p>
				<p>
					<b>Throws:</b> memory allocation exceptions
				</p>
			</blockquote>
		</blockquote>






		<h3>&nbsp; <a name="section">section</a></h3>

		<blockquote>
			<pre>section(const std::string&amp; _name);</pre>
			<blockquote>
				<p>
					<b>Preconditions:</b> the parameter name is not empty; though this is
					currently not enforced since we need a default parameter with an empty
					name (see the [] operators.)
				</p>
				<p>
					<b>Effects:</b> create a section named <code>_name</code>.
				</p>
				<p>
					<b>Postconditions:</b> the section name cannot be changed.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>const std::string&amp; get_name() const;</pre>
			<blockquote>
				<p>
					<b>Postconditions:</b> the returned string cannot be modified.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>void set_comment(const std::string&amp; comment);</pre>
			<blockquote>
				<p>
					<b>Effects:</b> assigns a comment to that object. Comments
					are written right before sections. Comments read right
					before a section are assigned to that section. Comments
					read right after a section are assigned the the first
					parameter. If there is no parameter, it is assigned to
					the next section. If there is no other section or parameter,
					it is lost.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>const std::string&amp; get_comment() const;</pre>
			<blockquote>
				<p>
					<b>Postconditions:</b> the returned string cannot be modified; use
					<b>set_comment()</b> to modify a comment.
				</p>
				<p>
					<b>Throws:</b> nothing
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>void insert(boost::shared_ptr&lt;param&gt; _p);</pre>
			<blockquote>
				<p>
					<b>Precondition:</b> if the pointer is null, nothing happens and the
					function returns right away.
				</p>
				<p>
					<b>Effects:</b> add the specified parameter in the map of parameters.
					The use of a map makes it faster to retrieve parameters. However, this
					means you lose the possible ordering from input files.
				</p>
				<p>
					<b>Throws:</b> memory allocation exceptions
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>param&amp; operator [] (const std::string&amp; _name);
const param&amp; operator [] (const std::string&amp; _name) const;</pre>
			<blockquote>
				<p>
					<b>Precondition:</b> if a parameter with the specified <code>_name</code>
					does not exist:
					<ul>
						<li><i>Non-constant parameter map</i></li>
						<p>
							When the non-constant operator is used, a new parameter
							is created if none already exist with that <code>_name</code>.
						</p>
						<p>
						<li><i>Constant parameter map</i></li>
						<p>
							When the constant operator is used, it returns an empty
							parameter which must not be modified.
							That empty parameter is not part of the map.
						</p>
					</ul>
				</p>
				<p>
					<b>Effects:</b> return the empty parameter, an existing parameter or
					a new parameter with the specified <code>_name</code>.
				</p>
				<p>
					<b>Throws:</b> memory allocation exceptions
				</p>
			</blockquote>
		</blockquote>





		<h3>&nbsp; <a name="section_map">section_map</a></h3>

		<blockquote>
			<pre>void insert(boost::shared_ptr&lt;section&gt; _s);</pre>
			<blockquote>
				<p>
					<b>Precondition:</b> if the pointer is null, nothing happens and the
					function returns right away.
				</p>
				<p>
					<b>Effects:</b> add the specified section in the map of sections.
					The use of a map makes it faster to retrieve sections. However, this
					means you lose the possible ordering from input files.
				</p>
				<p>
					<b>Throws:</b> memory allocation exceptions
				</p>
			</blockquote>
		</blockquote>

		<blockquote>
			<pre>section&amp; operator [] (const std::string&amp; _name);
const section&amp; operator [] (const std::string&amp; _name) const;</pre>
			<blockquote>
				<p>
					<b>Precondition:</b> if a section with the specified <code>_name</code>
					does not exist:
					<ul>
						<li><i>Non-constant section map</i></li>
						<p>
							When the non-constant operator is used, a new section
							is created if none already exist with that <code>_name</code>.
						</p>
						<p>
						<li><i>Constant section map</i></li>
						<p>
							When the constant operator is used, it returns an empty
							section which must not be modified.
							That empty section is not part of the map.
						</p>
					</ul>
				</p>
				<p>
					<b>Effects:</b> return the empty section, an existing section or
					a new section with the specified <code>_name</code>.
				</p>
				<p>
					<b>Throws:</b> memory allocation exceptions
				</p>
			</blockquote>
		</blockquote>



		<h3>&nbsp; <a name="helpers">Helper functions</a></h3>

		<blockquote>
			<pre>extern std::istream&amp; operator &gt;&gt; (std::istream&amp; in, section_map&amp; _section_map);

extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const param&amp; _param);
extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const section&amp; _section);

extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const param_map&amp; _param_map);
extern std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const section_map&amp; _section_map);
</pre>
			<blockquote>
				<p>
					<b>Precondition:</b> to write a parameter, section or a map thereof, all the
					parameters and sections must have a valid name (i.e. not empty.) A section
					can be empty (have no parameters.)
				</p>
				<p>
					<b>Effects:</b> the &gt;&gt; oparator appends the content of the input stream
					to the specified <code>_section_map</code>. If the input includes sections
					and parameters which already exist in the <code>_section_map</code>, they
					will be overwritten (i.e. thus you can define defaults before to use the
					&gt;&gt; operator.) The &lt;&lt; operators print out the specified parameter. In
					all cases, the output ends with a newline. A section ends with an empty
					line. To save a section map to an init file, use the &lt;&lt; operator
					accepting a <code>_section_map</code> reference.
				</p>
				<p>
					<b>Throws:</b> the output operators (&lt;&lt;) can throw the
					<b>ini_exceptions::param_name_missing</b> or
					<b>ini_exceptions::section_name_missing</b> exceptions.
					The input operator (&gt;&gt;) can throw many different exceptions
					when the input file is invalid:
					<ul>
						<li><b>ini_exceptions::invalid_section_name</b></li>
						<li><b>ini_exceptions::invalid_param_name</b></li>
						<li><b>ini_exceptions::param_without_section</b></li>
						<li><b>ini_exceptions::invalid_parameter</b></li>
						<li><b>ini_exceptions::invalid_quotation</b></li>
					</ul>
				</p>
			</blockquote>
		</blockquote>


	</div>

	<hr/>

	<p style="font-size: 75%; text-align: center;">
		<u>Copyright (c) 2006 Alexis Wilke</u><br/>
		<br/>
		<i>Permission to copy, use, modify, sell and distribute this document is granted provided<br/>
		this copyright notice appears in all copies. This document is provided "as is" without<br/>
		express or implied warranty, and with no claim as to its suitability for any purpose.</i>
	</p>
</body>
<!--
	vim: ts=2
-->
</html>
